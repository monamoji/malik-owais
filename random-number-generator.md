Recently considering the implementation of a decentralized casino based on Ethereum, a random number is necessary if the casino needs to be implemented. Then I studied the random number generation in Ethereum and found that it was not easy. You can refer to Monte Carlo Methods in Practice.

There are several ways to generate random numbers in Ethereum.

# oraclize

Oraclize is positioned as a data porter for decentralized applications as a reliable link to Web APIs and DApps. With Oraclize, there is no need to build an extra chain of trust because our behavior has been forced to be encrypted. Oraclize is a provable and honest oracle service that allows smart contracts to access the Internet. Oraclize is platform-independent and provides a virtual interface to all major smart contract platforms. It is conceivable that investing a lot of meaningful data into the blockchain through Oraclize can make the smart contract industry more prosperous and make more valuable applications more vital.

How to use Oraclize can refer to the following[code](https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)

In the update method, call the oraclize_newRandomDSQuery method to call Oracle's smart contract code. Oracle generates the corresponding data according to the request, and then passes the result through the callback \_\_callback.

```js
/*
		Oraclize random-datasource example

		This contract uses the random-datasource to securely generate off-chain N random bytes
*/

pragma solidity ^0.4.11;

import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";

contract RandomExample is usingOraclize {

		event newRandomNumber_bytes(bytes);
		event newRandomNumber_uint(uint);

		function RandomExample() {
				oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof in the constructor
				update(); // let's ask for N random bytes immediately when the contract is created!
		}

		// the callback function is called by Oraclize when the result is ready
		// the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:
		// the proof validity is fully verified on-chain
		function __callback(bytes32 _queryId, string _result, bytes _proof)
		{
				// if we reach this point successfully, it means that the attached authenticity proof has passed!
				if (msg.sender != oraclize_cbAddress()) throw;

				if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
						// the proof verification has failed, do we need to take any action here? (depends on the use case)
				} else {
						// the proof verification has passed
						// now that we know that the random number was safely generated, let's use it..

						newRandomNumber_bytes(bytes(_result)); // this is the resulting random number (bytes)

						// for simplicity of use, let's also convert the random bytes to uint if we need
						uint maxRange = 2**(8* 7); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return
						uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range

						newRandomNumber_uint(randomNumber); // this is the resulting random number (uint)
				}
		}

		function update() payable {
				uint N = 7; // number of random bytes we want the datasource to return
				uint delay = 0; // number of seconds to wait before the execution takes place
				uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function
				bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId
		}

}
```

Consider a smart contract that offers betting. The user invokes the betting interface, which stores the user's request and then invokes the Oracle random number generation service. Then through the Oracle callback service, determine whether the random number is greater than a certain value. If it is established, the user succeeds, otherwise the user fails.

This is a typical Oracle use case.

# RANDAO: A DAO working as RNG of Ethereum

[randao](https://github.com/randao/randao)is a decentralized organization that generates Ethereum random numbers.

**Random number in programming is very important!**

**RNG in a deterministic system is very difficult**

**Miners can't be trusted!**

Random numbers are very important in programming. RNG is very difficult in a deterministic system. Can't believe miners

## solution

Solutions

A DAO (decentralised autonomous organisation) that anyone can participate in, and the random number is generated by all participants together! First of all, we need to create a RANDAO contract in the blockchain, which defines the participation rules. Then the basic proc